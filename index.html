const reqlib = require("app-root-path").require;
const jwt = require("jsonwebtoken");
const moment = require("moment");
const httpStatus = require("http-status");
const config = reqlib("/config/config");
const userService = require("./user.service");
const { Token, User } = reqlib("/models");
const ApiError = reqlib("/utils/ApiError");
const { tokenTypes } = reqlib("/config/tokens");
const { sendServiceSuccessObj, defaultSuccessMessage } =
  reqlib("/utils/success");
const { sendFailureResponse, sendServiceFailureObj } = reqlib("/utils/failure");

/**
 * Generate token
 * @param {ObjectId} userId
 * @param {Moment} expires
 * @param {string} type
 * @param {string} [secret]
 * @returns {string}
 */
const generateToken = (userId, expires, type, options = {}) => {
  const payload = {
    sub: userId,
    iat: Date.now(),
    exp: expires.unix(),
    type,
  };
  return jwt.sign(payload, config.jwt.secret, options);
};

/**
 * Save a token
 * @param {Object} token
 * @param {ObjectId} userId
 * @returns {Promise<User>}
 */
const saveToken = async (tokens, userId) => {
  // console.log(`saveToken (user: ${userId})`, tokens);
  const filter = { _id: userId };
  const update = { ...tokens };
  const options = { new: true };

  const user = await User.findOneAndUpdate(filter, update, options);
  // console.log('Saved token', user);
  return user;
};

/**
 * Verify token and return token doc (or throw an error if it is not valid)
 * @param {string} token
 * @param {string} type
 * @returns {Promise<Token>}
 */
// const verifyToken = async (token) => {
//   const payload = jwt.verify(token, config.jwt.secret);
//   const user = await User.findOne({ _id : payload.sub});
//   //const user = await User.findOne({ id : payload.sub, access_token : token});
//   if (!user) {
//     throw new Error('User not found.');
//   }
//   return user;
// };

const verifyToken = (token, options = {}) => {
  try {
    const payload = jwt.verify(token, config.jwt.secret, options);
    return sendServiceSuccessObj(defaultSuccessMessage, payload);
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      return sendServiceFailureObj("Token expired", httpStatus.UNAUTHORIZED);
    }
    return sendServiceFailureObj(
      `Caught exception verifying token: ${error}`,
      httpStatus.UNAUTHORIZED,
    );
  }
};

/**
 * Generate auth tokens
 * @param {User} user
 * @returns {Promise<Object>}
 */
const generateAuthTokens = async (user) => {
  // const accessTokenExpires = moment().add(config.jwt.accessExpirationMinutes, 'minutes');
  const accessTokenExpires = moment().add(
    config.jwt.accessExpirationDays,
    "days",
  );
  const accessToken = generateToken(
    user._id,
    accessTokenExpires,
    tokenTypes.ACCESS,
  );

  const refreshTokenExpires = moment().add(
    config.jwt.refreshExpirationDays,
    "days",
  );
  const refreshToken = generateToken(
    user._id,
    refreshTokenExpires,
    tokenTypes.REFRESH,
  );
  await saveToken(
    { access_token: accessToken, refresh_token: refreshToken },
    user._id,
  );

  const tokenData = {
    access: {
      token: accessToken,
      expires: accessTokenExpires.toDate(),
    },
    refresh: {
      token: refreshToken,
      expires: refreshTokenExpires.toDate(),
    },
  };

  return sendServiceSuccessObj(defaultSuccessMessage, tokenData);
};

/**
 * Generate auth tokens
 * @param {User} user
 * @returns {Promise<Object>}
 */
const generateWebAuthTokens = async (user) => {
  // const accessTokenExpires = moment().add(config.jwt.accessExpirationMinutes, 'minutes');
  const accessTokenExpires = moment().add(
    config.jwt.accessExpirationDays,
    "days",
  );
  const accessToken = generateToken(
    user.id,
    accessTokenExpires,
    tokenTypes.ACCESS,
  );

  const refreshTokenExpires = moment().add(
    config.jwt.refreshExpirationDays,
    "days",
  );
  const refreshToken = generateToken(
    user.id,
    refreshTokenExpires,
    tokenTypes.REFRESH,
  );
  // await saveToken({ access_token: accessToken, refresh_token: refreshToken }, user.id);

  const tokenData = {
    access: {
      token: accessToken,
      expires: accessTokenExpires.toDate(),
    },
    refresh: {
      token: refreshToken,
      expires: refreshTokenExpires.toDate(),
    },
  };

  return sendServiceSuccessObj(defaultSuccessMessage, tokenData);
};

/**
 * Generate auth tokens
 * @param {User} user
 * @returns {Promise<Object>}
 */
const generateAccessTokenFromRefreshToken = async (user) => {
  if (!user.refresh_token) {
    throw new ApiError(httpStatus.UNAUTHORIZED, "Refresh token not found.");
  }
  // const accessTokenExpires = moment().add(config.jwt.accessExpirationMinutes, 'minutes');
  const accessTokenExpires = moment().add(
    config.jwt.accessExpirationDays,
    "days",
  );
  const accessToken = generateToken(
    user.id,
    accessTokenExpires,
    tokenTypes.ACCESS,
  );

  await saveToken({ access_token: accessToken }, user.id);

  return {
    access: {
      token: accessToken,
      expires: accessTokenExpires.toDate(),
    },
  };
};

/**
 * Generate reset password token
 * @param {string} email
 * @returns {Promise<string>}
 */
const generateResetPasswordToken = async (email) => {
  const user = await userService.getUserByEmail(email);
  if (!user) {
    return sendServiceFailureObj("No users found with this email");
  }

  if (user && user.is_deleted == true) {
    return sendServiceFailureObj("Your account is inactive.");
  }

  const expires = moment().add(
    config.jwt.resetPasswordExpirationMinutes,
    "minutes",
  );
  const resetPasswordToken = generateToken(
    user.id,
    expires,
    tokenTypes.RESET_PASSWORD,
  );
  await saveToken(resetPasswordToken, user.id);

  return sendServiceSuccessObj(defaultSuccessMessage, resetPasswordToken);
};

//web
const generateRandomSixDigit = (digit) => {
  const min = 10 ** (digit - 1); // Minimum value with specified digits
  const max = 10 ** digit - 1; // Maximum value with specified digits

  // Generate a random number within the specified range
  const otp = Math.floor(min + Math.random() * (max - min + 1));
  return otp;
};

function generateRandomUniqueKey(length) {
  const charset =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  if (typeof length !== "number" || length <= 0) {
    throw new Error("Invalid length. Please provide a positive number.");
  }

  let key = "";
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * charset.length);
    key += charset.charAt(randomIndex);
  }

  return key;
}
const generateOTP = async (email) => {
  const user = await userService.getUserByEmail(email);
  if (!user || user === null) {
    return sendServiceFailureObj(
      "No users found with this email",
      httpStatus.UNAUTHORIZED,
    );
  }

  if (user && user.is_deleted == true) {
    return sendServiceFailureObj(
      "Your account is inactive.",
      httpStatus.FORBIDDEN,
    );
  }

  const OTP = generateRandomSixDigit(6);
  const otpUniqueKey = generateRandomUniqueKey(60);
  user.otp = OTP;
  user.otpUniqueKey = otpUniqueKey;
  await user.save();

  return sendServiceSuccessObj(defaultSuccessMessage, { OTP, otpUniqueKey });
};

const adminGenerateResetPasswordToken = async (email) => {
  const admin = await userService.getUserByEmail(email);
  if (!admin) {
    throw new ApiError(httpStatus.NOT_FOUND, "No admin found with this email");
  }
  const expires = moment().add(
    config.jwt.resetPasswordExpirationMinutes,
    "minutes",
  );
  const resetPasswordToken = generateToken(
    admin.id,
    expires,
    tokenTypes.RESET_PASSWORD,
  );
  await saveToken(resetPasswordToken, admin.id);
  return resetPasswordToken;
};

/**
 * Generate verify email token
 * @param {User} user
 * @returns {Promise<string>}
 */
const generateVerifyEmailToken = async (user) => {
  const expires = moment().add(
    config.jwt.verifyEmailExpirationMinutes,
    "minutes",
  );
  const verifyEmailToken = generateToken(
    user._id,
    expires,
    tokenTypes.VERIFY_EMAIL,
  );
  await saveToken(
    {
      verify_email_token: verifyEmailToken,
      expires: expires,
    },
    user.id,
  );
  return verifyEmailToken;
};

module.exports = {
  generateToken,
  saveToken,
  verifyToken,
  generateAuthTokens,
  generateWebAuthTokens,
  generateAccessTokenFromRefreshToken,
  generateResetPasswordToken,
  generateVerifyEmailToken,
  adminGenerateResetPasswordToken,
  generateOTP,
};
