<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ONE Local Object Builder</title>
  <!-- Responsive Meta Tag -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Material-UI CSS -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <!-- Material Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #f5f5f5;
    }
    #root {
      padding: 20px;
    }
    .json-output {
      width: 100%;
      height: 300px;
      margin-top: 20px;
      padding: 10px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      background-color: #e0e0e0;
      border-radius: 8px;
      overflow: auto;
    }
    .nested-form {
      border-left: 2px solid #ccc;
      padding-left: 15px;
      margin-bottom: 20px;
    }
    .card-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 20px;
    }
    .card-item {
      width: 300px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React and ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- Babel for JSX Transformation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Material-UI Components -->
  <script src="https://unpkg.com/@mui/material@5.11.0/umd/material-ui.development.js" crossorigin></script>
  <script src="https://unpkg.com/@mui/icons-material@5.11.0/umd/material-ui-icons.development.js" crossorigin></script>

  <script type="text/babel">
    const {
      Button,
      TextField,
      Select,
      MenuItem,
      FormControl,
      InputLabel,
      Tabs,
      Tab,
      Box,
      Typography,
      Autocomplete,
      Grid,
      Paper,
      Checkbox,
      FormControlLabel,
      Chip,
      IconButton,
      Dialog,
      DialogTitle,
      DialogContent,
      DialogContentText,
      DialogActions,
      Card,
      CardContent,
      CardActions,
      Divider,
    } = MaterialUI;

    // Define the object types and their properties
    const objectTypes = [
      // ... [Your existing objectTypes array remains unchanged]
      // Ensure you include the entire objectTypes array as provided in your initial code.
      // For brevity, only a sample is included here. Replace this with your full array.
      {
        name: 'Person',
        properties: [
          { label: 'ID', name: '@id', type: 'text', required: true },
          { label: 'Type', name: '@type', type: 'text', default: 'schema:Person', disabled: true },
          { label: 'Name', name: 'name', type: 'text', required: true },
          { label: 'Email', name: 'email', type: 'email' },
          { label: 'Telephone', name: 'telephone', type: 'tel' },
          { label: 'Description', name: 'description', type: 'textarea' },
          { label: 'Address', name: 'address', type: 'object', fields: [
              { label: 'Street Address', name: 'streetAddress', type: 'text' },
              { label: 'City', name: 'addressLocality', type: 'text' },
              { label: 'Region', name: 'addressRegion', type: 'text' },
              { label: 'Postal Code', name: 'postalCode', type: 'text' },
              { label: 'Country', name: 'addressCountry', type: 'text' },
            ]
          },
          // Add other properties as needed
        ],
      },
      // Add other object types (Organization, Group, Event, etc.)
    ];

    // Dummy Data for Dropdowns (initial options)
    const initialDummyData = {
      users: [
        { label: 'Jane Doe', value: 'urn:uuid:user123' },
        { label: 'John Smith', value: 'urn:uuid:user456' },
        { label: 'Emily Clark', value: 'urn:uuid:user789' },
      ],
      organizations: [
        { label: 'ONE Local', value: 'urn:uuid:org001' },
        { label: 'Boulder Farmers Co-op', value: 'urn:uuid:org456' },
      ],
      roles: [
        { label: 'CEO', value: 'CEO' },
        { label: 'COO', value: 'COO' },
        { label: 'CMO', value: 'CMO' },
        { label: 'Resource Manager', value: 'Resource Manager' },
        { label: 'Event Coordinator', value: 'Event Coordinator' },
        { label: 'Group Moderator', value: 'Group Moderator' },
      ],
      skills: [
        { label: 'Strategic Planning', value: 'Strategic Planning' },
        { label: 'Leadership', value: 'Leadership' },
        { label: 'Gardening', value: 'Gardening' },
        { label: 'Carpentry', value: 'Carpentry' },
      ],
      // Add other dummy data as needed
    };

    // Helper Functions
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function formatLabel(label) {
      // Convert camelCase or snake_case to Regular Case
      return label
        .replace(/([A-Z])/g, ' $1')
        .replace(/_/g, ' ')
        .replace(/^./, function(str){ return str.toUpperCase(); });
    }

    function setNestedValue(obj, path, value) {
      const keys = path.split('.');
      const lastKey = keys.pop();
      const newObj = { ...obj };
      let current = newObj;
      keys.forEach(key => {
        if (!current[key] || typeof current[key] !== 'object') {
          current[key] = {};
        } else {
          current[key] = { ...current[key] };
        }
        current = current[key];
      });
      current[lastKey] = value;
      return newObj;
    }

    function getNestedValue(obj, path) {
      return path.split('.').reduce((acc, part) => acc && acc[part], obj);
    }

    // Main App Component
    function App() {
      const [selectedType, setSelectedType] = React.useState(objectTypes[0].name);
      const [formData, setFormData] = React.useState({});
      const [jsonOutput, setJsonOutput] = React.useState('');
      const [createdObjects, setCreatedObjects] = React.useState({
        Person: [],
        Organization: [],
        Group: [],
        Event: [],
        Task: [],
        Resource: [],
        Offer: [],
        Demand: [],
      });
      const [dummyData, setDummyData] = React.useState(initialDummyData);
      const [modalOpen, setModalOpen] = React.useState(false);
      const [selectedObject, setSelectedObject] = React.useState(null);
      const [formErrors, setFormErrors] = React.useState({});

      // Handle Tab Change
      const handleChange = (event, newValue) => {
        setSelectedType(newValue);
        setFormData({});
        setJsonOutput('');
        setFormErrors({});
      };

      // Update JSON Output whenever formData changes
      React.useEffect(() => {
        setJsonOutput(JSON.stringify(formData, null, 2));
      }, [formData]);

      // Get the schema for the selected object type
      const currentSchema = objectTypes.find(obj => obj.name === selectedType);

      // Validate required fields
      const validateForm = () => {
        const errors = {};
        currentSchema.properties.forEach(prop => {
          if (prop.required) {
            if (prop.type === 'object') {
              prop.fields.forEach(field => {
                const fieldValue = getNestedValue(formData, `${prop.name}.${field.name}`);
                if (!fieldValue && fieldValue !== 0) {
                  errors[`${prop.name}.${field.name}`] = `${field.label} is required`;
                }
              });
            } else {
              if ((formData[prop.name] === undefined || formData[prop.name] === '') && formData[prop.name] !== 0) {
                errors[prop.name] = `${prop.label} is required`;
              }
            }
          }
        });
        setFormErrors(errors);
        return Object.keys(errors).length === 0;
      };

      // Handle Form Submission
      const handleSubmit = () => {
        if (validateForm()) {
          if (currentSchema) {
            setCreatedObjects(prev => ({
              ...prev,
              [selectedType]: [...prev[selectedType], formData],
            }));

            // Update dummyData for multiselects with new entries
            currentSchema.properties.forEach(prop => {
              if (prop.type === 'multiselect' && formData[prop.name]) {
                const newOptions = formData[prop.name]
                  .filter(item => !dummyData[prop.name]?.some(option => option.value === item))
                  .map(item => ({ label: item, value: item }));
                if (newOptions.length > 0) {
                  setDummyData(prev => ({
                    ...prev,
                    [prop.name]: [...(prev[prop.name] || []), ...newOptions],
                  }));
                }
              }
            });

            // Reset form
            setFormData({});
            setFormErrors({});
          }
        } else {
          // Scroll to the first error
          const firstErrorField = document.querySelector('[data-error="true"]');
          if (firstErrorField) {
            firstErrorField.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      };

      // Handle Modal Open
      const handleModalOpen = (object, type) => {
        setSelectedObject({ ...object, type });
        setModalOpen(true);
      };

      // Handle Modal Close
      const handleModalClose = () => {
        setModalOpen(false);
        setSelectedObject(null);
      };

      return (
        <Box sx={{ width: '100%' }}>
          <Typography variant="h4" align="center" gutterBottom sx={{ mt: 4 }}>
            ONE Local Object Builder
          </Typography>
          <Tabs
            value={selectedType}
            onChange={handleChange}
            variant="scrollable"
            scrollButtons="auto"
            centered
          >
            {objectTypes.map((obj) => (
              <Tab key={obj.name} label={obj.name} value={obj.name} />
            ))}
          </Tabs>
          <Box sx={{ p: 3 }}>
            <ObjectForm
              schema={currentSchema}
              formData={formData}
              setFormData={setFormData}
              dummyData={dummyData}
              setDummyData={setDummyData}
              formErrors={formErrors}
            />
            <Button variant="contained" color="primary" onClick={handleSubmit}>
              Create {selectedType}
            </Button>
            <Typography variant="h6" sx={{ mt: 4 }}>
              JSON Output:
            </Typography>
            <Paper variant="outlined" className="json-output">
              <pre>{jsonOutput}</pre>
            </Paper>
            <Typography variant="h5" sx={{ mt: 6, mb: 2 }}>
              Created {selectedType}s
            </Typography>
            <Box className="card-grid">
              {createdObjects[selectedType].map((obj, idx) => (
                <Card key={idx} className="card-item">
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      {obj.name}
                    </Typography>
                    <Typography variant="body2" color="textSecondary">
                      {obj.description || 'No Description'}
                    </Typography>
                  </CardContent>
                  <CardActions>
                    <Button size="small" onClick={() => handleModalOpen(obj, selectedType)}>View Details</Button>
                  </CardActions>
                </Card>
              ))}
            </Box>
          </Box>
          {/* Detail Modal */}
          {selectedObject && (
            <Dialog open={modalOpen} onClose={handleModalClose} maxWidth="xs" fullWidth>
              <Card sx={{ borderRadius: 2, overflow: 'hidden' }}>
                {selectedObject.image && (
                  <Box
                    component="img"
                    sx={{
                      height: 200,
                      width: '100%',
                      objectFit: 'cover',
                    }}
                    alt={selectedObject.name}
                    src={selectedObject.image}
                  />
                )}
                <DialogTitle sx={{ textAlign: 'center' }}>{selectedObject.name}</DialogTitle>
                <DialogContent dividers>
                  <CardContent>
                    <Grid container spacing={1}>
                      {Object.entries(selectedObject).map(([key, value], index) => {
                        if (key === '@type') return null; // Skip type or any other fields you don't want to display
                        if (key === 'image') return null; // Already displayed as image
                        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                          return (
                            <React.Fragment key={index}>
                              <Grid item xs={12}>
                                <Typography variant="subtitle1" sx={{ mt: 2 }}>
                                  {capitalizeFirstLetter(key)}
                                </Typography>
                                <Divider />
                              </Grid>
                              {Object.entries(value).map(([subKey, subValue], subIndex) => (
                                <Grid item xs={12} sm={6} key={`${index}-${subIndex}`}>
                                  <Typography variant="body2" color="textSecondary">
                                    <strong>{formatLabel(subKey)}:</strong> {subValue || 'N/A'}
                                  </Typography>
                                </Grid>
                              ))}
                            </React.Fragment>
                          );
                        }
                        if (Array.isArray(value)) {
                          return (
                            <Grid item xs={12} sm={6} key={index}>
                              <Typography variant="body2" color="textSecondary">
                                <strong>{formatLabel(key)}:</strong> {value.length > 0 ? value.join(', ') : 'N/A'}
                              </Typography>
                            </Grid>
                          );
                        }
                        return (
                          <Grid item xs={12} sm={6} key={index}>
                            <Typography variant="body2" color="textSecondary">
                              <strong>{formatLabel(key)}:</strong> {value || 'N/A'}
                            </Typography>
                          </Grid>
                        );
                      })}
                    </Grid>
                  </CardContent>
                </DialogContent>
                <DialogActions>
                  <Button onClick={handleModalClose}>Close</Button>
                </DialogActions>
              </Card>
            </Dialog>
          )}
        </Box>
      );

      // ObjectForm Component
      function ObjectForm({ schema, formData, setFormData, dummyData, setDummyData, formErrors }) {
        // Handle input changes
        const handleChange = (name, value) => {
          setFormData(prev => setNestedValue(prev, name, value));
        };

        // Recursive function to handle nested objects and arrays
        const renderFields = (properties, parentName = '') => {
          return properties.map((prop, index) => {
            const fullName = parentName ? `${parentName}.${prop.name}` : prop.name;
            const value = getNestedValue(formData, fullName) || (prop.type === 'multiselect' ? [] : '');
            const error = formErrors[fullName];

            switch (prop.type) {
              case 'text':
              case 'email':
              case 'tel':
              case 'url':
              case 'number':
              case 'date':
              case 'datetime-local':
              case 'password':
                return (
                  <Box key={index} sx={{ mb: 3 }}>
                    <TextField
                      label={prop.label}
                      type={prop.type === 'textarea' ? 'text' : prop.type}
                      multiline={prop.type === 'textarea'}
                      rows={prop.type === 'textarea' ? 4 : 1}
                      fullWidth
                      disabled={prop.disabled}
                      required={prop.required}
                      value={value}
                      error={!!error}
                      helperText={error}
                      data-error={!!error}
                      onChange={(e) => handleChange(fullName, e.target.value)}
                    />
                  </Box>
                );
              case 'select':
                return (
                  <Box key={index} sx={{ mb: 3 }}>
                    <Autocomplete
                      freeSolo
                      options={dummyData[prop.name] ? dummyData[prop.name].map(option => option.value) : []}
                      value={value}
                      onChange={(event, newValue) => {
                        handleChange(fullName, newValue);
                      }}
                      onInputChange={(event, newInputValue) => {
                        handleChange(fullName, newInputValue);
                      }}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label={prop.label}
                          placeholder={`Select or create ${prop.label}`}
                          required={prop.required}
                        />
                      )}
                    />
                  </Box>
                );
              case 'multiselect':
                return (
                  <Box key={index} sx={{ mb: 3 }}>
                    <Autocomplete
                      multiple
                      freeSolo
                      options={dummyData[prop.name] ? dummyData[prop.name].map(option => option.value) : []}
                      value={value}
                      onChange={(event, newValue) => {
                        // Add new options to dummyData
                        const newEntries = newValue.filter(item => !dummyData[prop.name]?.some(option => option.value === item));
                        if (newEntries.length > 0) {
                          setDummyData(prev => ({
                            ...prev,
                            [prop.name]: [...(prev[prop.name] || []), ...newEntries.map(item => ({ label: item, value: item }))]
                          }));
                        }
                        handleChange(fullName, newValue);
                      }}
                      renderTags={(tagValue, getTagProps) =>
                        tagValue.map((option, index) => (
                          <Chip label={option} {...getTagProps({ index })} key={index} />
                        ))
                      }
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label={prop.label}
                          placeholder={`Select or create ${prop.label}`}
                        />
                      )}
                    />
                  </Box>
                );
              case 'checkbox':
                return (
                  <Box key={index} sx={{ mb: 3 }}>
                    <FormControlLabel
                      control={
                        <Checkbox
                          checked={value}
                          onChange={(e) => handleChange(fullName, e.target.checked)}
                        />
                      }
                      label={prop.label}
                    />
                  </Box>
                );
              case 'object':
                return (
                  <Box key={index} sx={{ mb: 3, pl: 3, borderLeft: '2px solid #ccc' }}>
                    <Typography variant="h6" gutterBottom>
                      {prop.label}
                    </Typography>
                    {renderFields(prop.fields, fullName)}
                  </Box>
                );
              default:
                return null;
            }
          });
        };

        return (
          <Box>
            {renderFields(schema.properties)}
          </Box>
        );
      }
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
