{
  "id": "U123",
  "agentId": "A123",
  "firstName": "Cam",
  "lastName": "Alot",
  "name": "Cam Alot",
  "nickName": "CamAlot",
  "userName": "camalot",
  "dateOfBirth": "1990-01-01",
  "password": "password",
  "alternateIdentities": {
    "agentId": "A124",
    "firstName": "Barry",
    "lastName": "Allen",
    "name": "Barry Allen",
    "moniker": "Scarlet Speedster",
    "userName": "CrimsonKing",
    "catchphrase": "Run fast",
    "email": "flash52@gmail.com",
    "alternateIdentities": []
  },
  "email": "camalot999@gmail.com",
  "phone": "123-456-7890",
  "address": {
    "street": "123 Main St.",
    "city": "Boulder",
    "state": "CO",
    "zip": "94105",
    "province": "",
    "country": "USA",
    "region": "West",
    "ecoregion": {
      "lv1_ecoregion": "Great Plains",
      "lv2_ecoregion": "South Central Semi-arid Prairies",
      "lv3_ecoregion": "High Plains",
      "lv4_ecoregion": "Front Range Fans"
    },
    "continent": "North America",
    "planet": "Earth",
    "starsystem": "Sol"
  },
  "location": {
    "name": "Cam's House",
    "venue": "Cam's House",
    "latitude": 37.783692,
    "longitude": -122.409972
  },
  "referredBy": {
    "id": "U124",
    "name": "Barry Allen"
  },
  "profilePicture": "https://www.google.com/profile.jpg",
  "backgroundPicture": "https://www.google.com/background.jpg",
  "description": "I'm a cool guy",
  "memberships": {
    "Player": [],
    "Producer": [],
    "ProductMerchant": [],
    "ServiceProvider": [],
    "orgOperator": []
  },
  "attributes": {
    "physicalTraits": [],
    "personalityTraits": [],
    "wealth": [],
    "humanDesign": "",
    "astrology": "",
    "numerology": "",
    "geneKeys": "",
    "myersBriggs": "",
    "enneagram": "",
    "bigFive": "",
    "strengthsFinder": "",
    "wealthDynamics": ""
  },
  "skills": {
    "Skill": []
  },
  "resources": {
    "asset": {
      "type": "Cash",
      "cashUSD": 1000,
      "crypto": "",
      "NFT": "",
      "inGameToken": "",
      "giftPoints": 0,
      "resource": ""
    },
    "quantity": 5,
    "location": "Location001",
    "permissions": {
      "canEdit": true,
      "canView": true,
      "canTake": true,
      "canTakeUser": true,
      "canTakeOrg": true,
      "canTakeGroup": true,
      "canTakeBadge": true
    },
    "minTokenQuantity": 10,
    "services": "Service1",
    "products": "Product1"
  },
  "organizations": ["Org001"],
  "groups": {
    "Group": []
  },
  "projects": ["Project001"],
  "events": {
    "producing": "User1",
    "maybeGoing": "E123",
    "went": "E123",
    "at": "E123",
    "going": "E123",
    "interested": "E123",
    "notGoing": "E123",
    "viewed": "E123",
    "created": "E123",
    "hosting": "E123"
  },
  "roles": [
    { "id": "Role001", "name": "CEO" }
  ],
  "tasks": [
    { "id": "Task001", "name": "Set up chairs" }
  ],
  "badges": [
    { "id": "Badge001", "name": "Community Leader", "description": "Leads community initiatives." }
  ],
  "products": [
    { "id": "Product001", "name": "Organic Apples", "description": "Freshly harvested organic apples.", "price": 2.99, "owner": "urn:uuid:user123" }
  ],
  "services": [
    { "id": "Service001", "name": "Gardening Workshop", "description": "Learn advanced gardening techniques.", "price": 50, "provider": "urn:uuid:user123" }
  ],
  "offers": [
    { "id": "Offer001", "description": "Offering free gardening tutorials.", "itemOffered": "Gardening Tips", "price": 0, "priceCurrency": "USD", "availability": "InStock", "validFrom": "2023-01-01T00:00", "validThrough": "2023-12-31T23:59", "seller": "urn:uuid:user123", "acceptedPaymentMethod": ["CreditCard", "PayPal"] }
  ],
  "requests": [
    { "id": "Request001", "description": "Requesting help to build a fence.", "buyer": "urn:uuid:user123" }
  ],
  "gratisPoints": [
    { "id": "Gratis001", "user": "urn:uuid:user123", "source": "Referral", "points": 100 }
  ],
  "posts": [
    { "id": "Post001", "content": "Excited to start the new gardening project!", "user": "urn:uuid:user123", "comments": ["Comment1", "Comment2"] }
  ],
  "interests": [
    { "id": "Interest001", "name": "Gardening", "users": ["urn:uuid:user123"] }
  ],
  "purchases": [
    { "id": "Purchase001", "product": "Product001", "buyer": "urn:uuid:user123" }
  ],
  "inGameTokens": [
    { "id": "Token001", "user": "urn:uuid:user123", "tokens": 500 }
  ],
  "friendships": {
    "Friendship": []
  },
      },
      // Define other object types here following the same pattern
    ];

    // Helper function to set nested values in an object
    const setNestedValue = (obj, path, value) => {
      const keys = path.split(/\.|\[|\].?/).filter(key => key);
      const lastKey = keys.pop();
      const nested = keys.reduce((acc, key) => {
        if (!acc[key]) acc[key] = {};
        return acc[key];
      }, obj);
      nested[lastKey] = value;
      return { ...obj };
    };

    // Helper function to get nested values from an object
    const getNestedValue = (obj, path) => {
      return path.split(/\.|\[|\].?/).reduce((acc, part) => acc && acc[part], obj);
    };

    // Main App Component
    function App() {
      const [selectedType, setSelectedType] = React.useState(objectTypes[0].name);
      const [formData, setFormData] = React.useState({});
      const [jsonOutput, setJsonOutput] = React.useState('');

      // Handle Tab Change
      const handleChange = (event, newValue) => {
        setSelectedType(newValue);
        setFormData({});
        setJsonOutput('');
      };

      // Update JSON Output whenever formData changes
      React.useEffect(() => {
        setJsonOutput(JSON.stringify(formData, null, 2));
      }, [formData]);

      // Get the schema for the selected object type
      const currentSchema = objectTypes.find(obj => obj.name === selectedType);

      return (
        <Box sx={{ width: '100%' }}>
          <Typography variant="h4" align="center" gutterBottom sx={{ mt: 4 }}>
            ONE Local Object Builder
          </Typography>
          <Tabs
            value={selectedType}
            onChange={handleChange}
            variant="scrollable"
            scrollButtons="auto"
            centered
          >
            {objectTypes.map((obj) => (
              <Tab key={obj.name} label={obj.name} value={obj.name} />
            ))}
          </Tabs>
          <Box sx={{ p: 3 }}>
            <ObjectForm
              schema={currentSchema}
              formData={formData}
              setFormData={setFormData}
              dummyData={dummyData}
            />
            <Typography variant="h6" sx={{ mt: 4 }}>
              JSON Output:
            </Typography>
            <Paper variant="outlined" className="json-output">
              <pre>{jsonOutput}</pre>
            </Paper>
          </Box>
        </Box>
      );
    }

    // ObjectForm Component
    function ObjectForm({ schema, formData, setFormData, dummyData }) {
      // Handle input changes
      const handleChange = (path, value) => {
        setFormData(prev => setNestedValue(prev, path, value));
      };

      // Recursive function to handle nested objects and arrays
      const renderFields = (properties, parentPath = '') => {
        return properties.map((prop, index) => {
          const currentPath = parentPath ? `${parentPath}.${prop.name}` : prop.name;
          const value = getNestedValue(formData, currentPath) || (prop.type === 'array' ? [] : (prop.type === 'object' ? {} : ''));

          switch (prop.type) {
            case 'text':
            case 'email':
            case 'tel':
            case 'url':
            case 'number':
            case 'date':
            case 'datetime-local':
            case 'password':
              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <TextField
                    label={prop.label}
                    type={prop.type === 'textarea' ? 'text' : prop.type}
                    multiline={prop.type === 'textarea'}
                    rows={prop.type === 'textarea' ? 4 : 1}
                    fullWidth
                    required={prop.required}
                    disabled={prop.disabled}
                    value={value}
                    onChange={(e) => handleChange(currentPath, e.target.value)}
                    helperText={prop.helperText || ''}
                  />
                </Box>
              );
            case 'select':
              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <FormControl fullWidth>
                    <InputLabel>{prop.label}</InputLabel>
                    <Select
                      value={value}
                      label={prop.label}
                      onChange={(e) => handleChange(currentPath, e.target.value)}
                    >
                      {prop.options.map((option, idx) => (
                        <MenuItem key={idx} value={option.value || option}>{option.label || option}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              );
            case 'multiselect':
              // Determine options based on property name
              let options = [];
              if (prop.options) {
                options = prop.options.map(opt => ({ label: opt, value: opt }));
              } else {
                // Dynamically assign options from dummyData based on name
                const key = prop.name.replace(/([A-Z])/g, '_$1').toLowerCase();
                options = dummyData[key] || [];
              }

              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <Autocomplete
                    multiple
                    options={options}
                    getOptionLabel={(option) => typeof option === 'string' ? option : option.label}
                    value={value.map(val => options.find(opt => opt.value === val) || { label: val, value: val })}
                    onChange={(event, newValue) => {
                      const selectedValues = newValue.map(item => typeof item === 'string' ? item : item.value);
                      handleChange(currentPath, selectedValues);
                    }}
                    renderTags={(tagValue, getTagProps) =>
                      tagValue.map((option, idx) => (
                        <Chip label={option.label || option} {...getTagProps({ index: idx })} key={idx} />
                      ))
                    }
                    renderInput={(params) => (
                      <TextField {...params} label={prop.label} placeholder={`Select ${prop.label}`} />
                    )}
                  />
                </Box>
              );
            case 'checkbox':
              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={value}
                        onChange={(e) => handleChange(currentPath, e.target.checked)}
                      />
                    }
                    label={prop.label}
                  />
                </Box>
              );
            case 'object':
              return (
                <Box key={index} className="nested-form">
                  <Typography variant="h6" gutterBottom>
                    {prop.label}
                  </Typography>
                  {renderFields(prop.fields, currentPath)}
                </Box>
              );
            case 'array':
              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <Typography variant="h6" gutterBottom>
                    {prop.label}
                  </Typography>
                  {value.map((item, idx) => (
                    <Box key={idx} sx={{ mb: 2, position: 'relative', padding: 2, border: '1px solid #ccc', borderRadius: 2 }}>
                      {renderFields(prop.fields, `${currentPath}[${idx}]`)}
                      <IconButton
                        aria-label="remove"
                        size="small"
                        sx={{ position: 'absolute', top: 0, right: 0 }}
                        onClick={() => removeArrayItem(currentPath, idx)}
                      >
                        <MaterialUI.Icon>close</MaterialUI.Icon>
                      </IconButton>
                    </Box>
                  ))}
                  <Button variant="contained" onClick={() => addArrayItem(currentPath, prop.fields)}>
                    Add {prop.label}
                  </Button>
                </Box>
              );
            default:
              return null;
          }
        });
      };

      // Helper functions to manage nested state
      const setNestedValue = (obj, path, value) => {
        const keys = path.split(/\.|\[|\].?/).filter(key => key);
        const lastKey = keys.pop();
        const nested = keys.reduce((acc, key) => {
          if (!acc[key]) acc[key] = {};
          return acc[key];
        }, obj);
        nested[lastKey] = value;
        return { ...obj };
      };

      const getNestedValue = (obj, path) => {
        return path.split(/\.|\[|\].?/).reduce((acc, part) => acc && acc[part], obj);
      };

      const addArrayItem = (path, fields) => {
        const currentArray = getNestedValue(formData, path) || [];
        const newItem = {};
        fields.forEach(field => {
          if (field.type === 'object') {
            newItem[field.name] = {};
          } else if (field.type === 'array') {
            newItem[field.name] = [];
          } else if (field.type === 'checkbox') {
            newItem[field.name] = false;
          } else {
            newItem[field.name] = '';
          }
        });
        handleChange(path, [...currentArray, newItem]);
      };

      const removeArrayItem = (path, index) => {
        const currentArray = getNestedValue(formData, path) || [];
        currentArray.splice(index, 1);
        handleChange(path, [...currentArray]);
      };

      // Render the form fields
      return (
        <Box>
          {renderFields(schema.properties)}
        </Box>
      );
    }

    // Render the App
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
