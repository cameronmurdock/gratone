<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ONE Local Object Builder</title>
  <!-- Responsive Meta Tag -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Material-UI CSS -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <!-- Material Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #f5f5f5;
    }
    #root {
      padding: 20px;
    }
    .json-output {
      width: 100%;
      height: 300px;
      margin-top: 20px;
      padding: 10px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      background-color: #e0e0e0;
      border-radius: 8px;
      overflow: auto;
    }
    .object-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-top: 20px;
    }
    .object-card {
      width: 300px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React and ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- Babel for JSX Transformation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Material-UI Components -->
  <script src="https://unpkg.com/@mui/material@5.11.0/umd/material-ui.development.js" crossorigin></script>
  <script src="https://unpkg.com/@mui/icons-material@5.11.0/umd/material-ui-icons.development.js" crossorigin></script>

  <script type="text/babel">
    const {
      Button,
      TextField,
      Select,
      MenuItem,
      FormControl,
      InputLabel,
      Tabs,
      Tab,
      Box,
      Typography,
      Autocomplete,
      Grid,
      Paper,
      Checkbox,
      FormControlLabel,
      Chip,
      IconButton,
      Modal,
      Card,
      CardContent,
      CardActions,
      Divider,
      Tooltip,
      Dialog,
      DialogTitle,
      DialogContent,
      DialogContentText,
      DialogActions,
    } = MaterialUI;

    // Define the object types and their properties
    const objectTypes = [
      // ... (Your existing objectTypes definition)
      // For brevity, I'll assume you have the 'Person', 'Organization', 'Group', 'Event', 'Task', 'Resource', 'Offer', 'Demand' defined as per your previous message.
      // Please ensure all objectTypes are included here as per your requirements.
      {
        name: 'Person',
        properties: [
          { label: 'ID', name: '@id', type: 'text', required: true },
          { label: 'Type', name: '@type', type: 'text', default: 'Person', disabled: true },
          { label: 'Name', name: 'name', type: 'text', required: true },
          { label: 'Alternate Name', name: 'alternateName', type: 'text' },
          { label: 'Identifier', name: 'identifier', type: 'text' },
          { label: 'Email', name: 'email', type: 'email' },
          { label: 'Telephone', name: 'telephone', type: 'tel' },
          { label: 'Image URL', name: 'image', type: 'url' },
          { label: 'Description', name: 'description', type: 'textarea' },
          { label: 'Same As', name: 'sameAs', type: 'multiselect', options: ['https://twitter.com/janedoe', 'https://linkedin.com/in/janedoe'] },
          { label: 'Birth Date', name: 'birthDate', type: 'date' },
          { label: 'Gender', name: 'gender', type: 'select', options: ['Male', 'Female', 'Non-binary', 'Other'] },
          { label: 'Address', name: 'address', type: 'object', fields: [
              { label: 'Street Address', name: 'streetAddress', type: 'text' },
              { label: 'City', name: 'addressLocality', type: 'text' },
              { label: 'Region', name: 'addressRegion', type: 'text' },
              { label: 'Postal Code', name: 'postalCode', type: 'text' },
              { label: 'Country', name: 'addressCountry', type: 'text' },
            ]
          },
          { label: 'Location', name: 'location', type: 'object', fields: [
              { label: 'Place Name', name: 'name', type: 'text' },
              { label: 'Latitude', name: 'latitude', type: 'number' },
              { label: 'Longitude', name: 'longitude', type: 'number' },
            ]
          },
          { label: 'Language', name: 'language', type: 'select', options: ['en-US', 'es-ES', 'fr-FR', 'de-DE'] },
          { label: 'Cultural Context', name: 'culturalContext', type: 'text' },
          { label: 'Member Of', name: 'memberOf', type: 'multiselect', options: ['urn:uuid:org001', 'urn:uuid:org456'] },
          { label: 'Has Role', name: 'hasRole', type: 'multiselect', options: ['CEO', 'COO', 'CMO'] },
          { label: 'Has Skill', name: 'hasSkill', type: 'multiselect', options: ['Strategic Planning', 'Leadership', 'Gardening', 'Carpentry'] },
          { label: 'Owns', name: 'owns', type: 'multiselect', options: ['3D Printer', 'Lawn Mower'] },
          { label: 'Makes Offer', name: 'makesOffer', type: 'multiselect', options: ['Free Tutoring', 'Tool Sharing'] },
          { label: 'Seeks', name: 'seeks', type: 'multiselect', options: ['Help Building Fence', 'Event Volunteers'] },
          { label: 'Has Badge', name: 'hasBadge', type: 'multiselect', options: ['Community Leader', 'Volunteer'] },
          { label: 'Has Reputation Score', name: 'hasReputationScore', type: 'number' },
          { label: 'Friend Of', name: 'friendOf', type: 'multiselect', options: ['urn:uuid:user456', 'urn:uuid:user789'] },
          { label: 'Collaborates With', name: 'collaboratesWith', type: 'multiselect', options: ['urn:uuid:org456'] },
          { label: 'Privacy Setting', name: 'privacySetting', type: 'text' },
          { label: 'User Preferences', name: 'userPreferences', type: 'textarea' },
          { label: 'Blockchain Identity', name: 'blockchainIdentity', type: 'text' },
          { label: 'Security Scheme', name: 'securityScheme', type: 'text' },
          { label: 'Proposes', name: 'proposes', type: 'multiselect', options: ['Proposal1', 'Proposal2'] },
          { label: 'Votes On', name: 'votesOn', type: 'multiselect', options: ['Vote1', 'Vote2'] },
          { label: 'Receives Notification', name: 'receivesNotification', type: 'multiselect', options: ['Notification1', 'Notification2'] },
          { label: 'Receives Alert', name: 'receivesAlert', type: 'multiselect', options: ['Alert1', 'Alert2'] },
          { label: 'Acted On Recommendation', name: 'actedOnRecommendation', type: 'multiselect', options: ['Recommendation1', 'Recommendation2'] },
          { label: 'Participates In Session', name: 'participatesInSession', type: 'multiselect', options: ['Session1', 'Session2'] },
        ],
      },
      // Add other object types (Organization, Group, Event, Task, Resource, Offer, Demand) similarly...
      // For brevity, only Person is fully defined here. Ensure to include all as per your schema.
      // ...
    ];

    // Dummy Data for Dropdowns
    const dummyData = {
      users: [
        { label: 'Jane Doe', value: 'urn:uuid:user123' },
        { label: 'John Smith', value: 'urn:uuid:user456' },
        { label: 'Emily Clark', value: 'urn:uuid:user789' },
      ],
      organizations: [
        { label: 'ONE Local', value: 'urn:uuid:org001' },
        { label: 'Boulder Farmers Co-op', value: 'urn:uuid:org456' },
      ],
      roles: [
        { label: 'CEO', value: 'CEO' },
        { label: 'COO', value: 'COO' },
        { label: 'CMO', value: 'CMO' },
        { label: 'Resource Manager', value: 'Resource Manager' },
        { label: 'Event Coordinator', value: 'Event Coordinator' },
        { label: 'Group Moderator', value: 'Group Moderator' },
      ],
      skills: [
        { label: 'Strategic Planning', value: 'Strategic Planning' },
        { label: 'Leadership', value: 'Leadership' },
        { label: 'Gardening', value: 'Gardening' },
        { label: 'Carpentry', value: 'Carpentry' },
      ],
      offers: [
        { label: 'Free Tutoring', value: 'Free Tutoring' },
        { label: 'Tool Sharing', value: 'Tool Sharing' },
        { label: 'Selling Fresh Produce', value: 'Selling Fresh Produce' },
      ],
      demands: [
        { label: 'Help Building Fence', value: 'Help Building Fence' },
        { label: 'Event Volunteers', value: 'Event Volunteers' },
        { label: 'Volunteer Gardeners', value: 'Volunteer Gardeners' },
      ],
      badges: [
        { label: 'Community Leader', value: 'Community Leader' },
        { label: 'Volunteer', value: 'Volunteer' },
      ],
      permissions: [
        { label: 'Use Permission', value: 'Use Permission' },
        { label: 'Read Permission', value: 'Read Permission' },
      ],
      proposals: [
        { label: 'Proposal1', value: 'Proposal1' },
        { label: 'Proposal2', value: 'Proposal2' },
      ],
      votes: [
        { label: 'Vote1', value: 'Vote1' },
        { label: 'Vote2', value: 'Vote2' },
      ],
      notifications: [
        { label: 'Notification1', value: 'Notification1' },
        { label: 'Notification2', value: 'Notification2' },
      ],
      alerts: [
        { label: 'Alert1', value: 'Alert1' },
        { label: 'Alert2', value: 'Alert2' },
      ],
      recommendations: [
        { label: 'Recommendation1', value: 'Recommendation1' },
        { label: 'Recommendation2', value: 'Recommendation2' },
      ],
      sessions: [
        { label: 'Session1', value: 'Session1' },
        { label: 'Session2', value: 'Session2' },
      ],
    };

    // Main App Component
    function App() {
      const [selectedType, setSelectedType] = React.useState(objectTypes[0].name);
      const [formData, setFormData] = React.useState({});
      const [jsonOutput, setJsonOutput] = React.useState('');
      const [objects, setObjects] = React.useState([]);
      const [selectedObject, setSelectedObject] = React.useState(null);

      // Handle Tab Change
      const handleChange = (event, newValue) => {
        setSelectedType(newValue);
        setFormData({});
        setJsonOutput('');
      };

      // Handle Form Submission
      const handleSubmit = (data) => {
        setObjects(prev => [...prev, data]);
      };

      // Update JSON Output whenever formData changes
      React.useEffect(() => {
        setJsonOutput(JSON.stringify(formData, null, 2));
      }, [formData]);

      // Get the schema for the selected object type
      const currentSchema = objectTypes.find(obj => obj.name === selectedType);

      return (
        <Box sx={{ width: '100%' }}>
          <Typography variant="h4" align="center" gutterBottom sx={{ mt: 4 }}>
            ONE Local Object Builder
          </Typography>
          <Tabs
            value={selectedType}
            onChange={handleChange}
            variant="scrollable"
            scrollButtons="auto"
            centered
          >
            {objectTypes.map((obj) => (
              <Tab key={obj.name} label={obj.name} value={obj.name} />
            ))}
          </Tabs>
          <Box sx={{ p: 3 }}>
            <ObjectForm
              schema={currentSchema}
              formData={formData}
              setFormData={setFormData}
              dummyData={dummyData}
              onSubmit={handleSubmit}
            />
            <Typography variant="h6" sx={{ mt: 4 }}>
              JSON Output:
            </Typography>
            <Paper variant="outlined" className="json-output">
              <pre>{jsonOutput}</pre>
            </Paper>
            <Divider sx={{ my: 4 }} />
            <Typography variant="h5" gutterBottom>
              Created Objects:
            </Typography>
            <ObjectCards objects={objects} onSelect={setSelectedObject} />
          </Box>
          {selectedObject && (
            <DetailModal object={selectedObject} onClose={() => setSelectedObject(null)} />
          )}
        </Box>
      );
    }

    // ObjectForm Component
    function ObjectForm({ schema, formData, setFormData, dummyData, onSubmit }) {
      // Handle input changes
      const handleChange = (name, value) => {
        setFormData(prev => setNestedValue(prev, name, value));
      };

      // Recursive function to handle nested objects
      const renderFields = (properties, parentName = '') => {
        return properties.map((prop, index) => {
          const fullName = parentName ? `${parentName}.${prop.name}` : prop.name;
          const value = getNestedValue(formData, fullName) || (prop.type === 'multiselect' ? [] : '');

          switch (prop.type) {
            case 'text':
            case 'email':
            case 'tel':
            case 'url':
            case 'number':
            case 'date':
            case 'datetime-local':
            case 'password':
              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <TextField
                    label={prop.label}
                    type={prop.type === 'textarea' ? 'text' : prop.type}
                    multiline={prop.type === 'textarea'}
                    rows={prop.type === 'textarea' ? 4 : 1}
                    fullWidth
                    disabled={prop.disabled}
                    required={prop.required}
                    value={value}
                    onChange={(e) => handleChange(fullName, e.target.value)}
                    helperText={prop.helperText || ''}
                  />
                </Box>
              );
            case 'select':
              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <FormControl fullWidth>
                    <InputLabel>{prop.label}</InputLabel>
                    <Select
                      value={value}
                      label={prop.label}
                      onChange={(e) => handleChange(fullName, e.target.value)}
                    >
                      {prop.options.map((option, idx) => (
                        <MenuItem key={idx} value={option}>{option}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              );
            case 'multiselect':
              // Determine options based on property name
              let options = [];
              if (prop.options) {
                options = prop.options;
              } else {
                // Dynamically assign options from dummyData based on name
                const key = prop.name.replace(/([A-Z])/g, '_$1').toLowerCase();
                options = dummyData[key] || [];
              }

              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <Autocomplete
                    multiple
                    options={options}
                    getOptionLabel={(option) => typeof option === 'string' ? option : option.label}
                    value={value}
                    onChange={(event, newValue) => {
                      const selectedValues = newValue.map(item => typeof item === 'string' ? item : item.value);
                      handleChange(fullName, selectedValues);
                    }}
                    renderTags={(tagValue, getTagProps) =>
                      tagValue.map((option, idx) => (
                        <Chip label={option} {...getTagProps({ index: idx })} key={idx} />
                      ))
                    }
                    renderInput={(params) => (
                      <TextField {...params} label={prop.label} placeholder={`Select ${prop.label}`} />
                    )}
                  />
                </Box>
              );
            case 'checkbox':
              return (
                <Box key={index} sx={{ mb: 3 }}>
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={value}
                        onChange={(e) => handleChange(fullName, e.target.checked)}
                      />
                    }
                    label={prop.label}
                  />
                </Box>
              );
            case 'object':
              return (
                <Box key={index} sx={{ mb: 3, pl: 3, borderLeft: '2px solid #ccc' }}>
                  <Typography variant="h6" gutterBottom>
                    {prop.label}
                  </Typography>
                  {renderFields(prop.fields, fullName)}
                </Box>
              );
            default:
              return null;
          }
        });
      };

      // Helper functions to manage nested state
      const setNestedValue = (obj, path, value) => {
        const keys = path.split(/\.|\[|\].?/).filter(key => key);
        const lastKey = keys.pop();
        const nested = keys.reduce((acc, key) => {
          if (!acc[key]) acc[key] = {};
          return acc[key];
        }, obj);
        nested[lastKey] = value;
        return { ...obj };
      };

      const getNestedValue = (obj, path) => {
        return path.split(/\.|\[|\].?/).reduce((acc, part) => acc && acc[part], obj);
      };

      // Handle form submission
      const handleSubmit = (e) => {
        e.preventDefault();
        onSubmit(formData);
        setFormData({});
      };

      // Render the form fields
      return (
        <Box component="form" onSubmit={handleSubmit}>
          {renderFields(schema.properties)}
          <Button variant="contained" color="primary" type="submit">
            Add {schema.name}
          </Button>
        </Box>
      );
    }

    // ObjectCards Component
    function ObjectCards({ objects, onSelect }) {
      return (
        <Box className="object-cards">
          {objects.map((obj, index) => (
            <Card key={index} className="object-card">
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {obj.name || obj['@type']}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Type: {obj['@type']}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  ID: {obj['@id']}
                </Typography>
              </CardContent>
              <CardActions>
                <Button size="small" onClick={() => onSelect(obj)}>View Details</Button>
              </CardActions>
            </Card>
          ))}
        </Box>
      );
    }

    // DetailModal Component
    function DetailModal({ object, onClose }) {
      return (
        <Modal
          open={Boolean(object)}
          onClose={onClose}
          aria-labelledby="object-detail-title"
          aria-describedby="object-detail-description"
        >
          <Box sx={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '80%',
            maxHeight: '80%',
            bgcolor: 'background.paper',
            boxShadow: 24,
            p: 4,
            overflow: 'auto',
            borderRadius: 2,
          }}>
            <Typography id="object-detail-title" variant="h6" component="h2" gutterBottom>
              {object.name || object['@type']}
            </Typography>
            <Divider sx={{ mb: 2 }} />
            <Box>
              {Object.entries(object).map(([key, value], index) => (
                key !== '@context' && (
                  <Box key={index} sx={{ mb: 2 }}>
                    <Typography variant="subtitle2" color="text.secondary">
                      {key}
                    </Typography>
                    <Typography variant="body1">
                      {renderValue(value)}
                    </Typography>
                  </Box>
                )
              ))}
            </Box>
            <Button variant="contained" onClick={onClose} sx={{ mt: 2 }}>
              Close
            </Button>
          </Box>
        </Modal>
      );
    }

    // Helper function to render different types of values
    function renderValue(value) {
      if (Array.isArray(value)) {
        return value.length > 0 ? value.join(', ') : 'N/A';
      } else if (typeof value === 'object' && value !== null) {
        return <pre style={{ whiteSpace: 'pre-wrap' }}>{JSON.stringify(value, null, 2)}</pre>;
      } else {
        return value || 'N/A';
      }
    }

    // Render the App
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
